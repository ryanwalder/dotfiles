#!/usr/bin/env bash
# Select a random image from a directory to set as a wallpaper and single/multi
# monitor lockscreen background
# Outputs: ~/.cache/wallpaper/lock.png & ~/.cache/wallpaper/current.png

source_dir=~/.wallpapers
cache_dir=~/.cache/wallpaper

if ! command -v xrandr >/dev/null 2>&1; then
    logger -t $(basename $0) -s "xrandr not found, exiting"
    exit 1
elif [[ ! -d ${source_dir} ]]; then
    logger -t $(basename $0) -s "${source_dir} does not exist"
    exit 1
elif [[ ! -d ${cache_dir} ]]; then
    mkdir ${cache_dir}
fi

image=$(find ${source_dir} -mindepth 1 -maxdepth 1 -type f | shuf -n1)

if [[ -z ${image} ]]; then
    logger -t $(basename $0) -s "No images found in ${source_dir}"
    exit 1
fi

wall_image=${cache_dir}/current.png
lock_image=${cache_dir}/lock.png
tmp_lock_image=${cache_dir}/tmp_lock.png
tmp_wall_image=${cache_dir}/tmp_wall.png

OUTPUT_IMG_WIDTH=0 # Decide size to cover all screens
OUTPUT_IMG_HEIGHT=0 # Decide size to cover all screens

#Execute xrandr to get information about the monitors:
DISPLAY_RE="([0-9]+)x([0-9]+)\\+([0-9]+)\\+([0-9]+)"
while read LINE
do
    #If we are reading the line that contains the position information:
    if [[ $LINE =~ $DISPLAY_RE ]]; then
        #Extract information and append some parameters to the ones that will be given to ImageMagick:
        SCREEN_WIDTH=${BASH_REMATCH[1]}
        SCREEN_HEIGHT=${BASH_REMATCH[2]}
        SCREEN_X=${BASH_REMATCH[3]}
        SCREEN_Y=${BASH_REMATCH[4]}

        tmp_res_image=${cache_dir}/tmp_${SCREEN_WIDTH}X${SCREEN_HEIGHT}.png
        if ! convert ${image} -resize ${SCREEN_WIDTH}X${SCREEN_HEIGHT}^ -gravity Center -crop ${SCREEN_WIDTH}X${SCREEN_HEIGHT}+0+0 +repage ${tmp_res_image}; then
            logger -t $(basename $0) -s "Failed to create cache image"
            exit 1
        fi

        # Decide size of output image
        if (( $OUTPUT_IMG_WIDTH < $SCREEN_WIDTH+$SCREEN_X )); then
            OUTPUT_IMG_WIDTH=$(($SCREEN_WIDTH+$SCREEN_X))
        fi
        if (( $OUTPUT_IMG_HEIGHT < $SCREEN_HEIGHT+$SCREEN_Y )); then
            OUTPUT_IMG_HEIGHT=$(( $SCREEN_HEIGHT+$SCREEN_Y ))
        fi;

        PARAMS="$PARAMS ${tmp_res_image} -geometry +$SCREEN_X+$SCREEN_Y -composite "
    fi
done <<<"`xrandr`"

## Convert
if ! convert -size ${OUTPUT_IMG_WIDTH}x${OUTPUT_IMG_HEIGHT} 'xc:black' ${tmp_lock_image}; then
    logger -t $(basename $0) -s "Failed to create temp lock image"
    exit 1
elif ! convert ${tmp_lock_image} $PARAMS ${tmp_lock_image}; then
    logger -t $(basename $0) -s "Failed to create temp lock image"
    exit 1
elif ! convert ${image} -resize ${SCREEN_WIDTH}X${SCREEN_HEIGHT}^ -gravity Center -crop ${SCREEN_WIDTH}X${SCREEN_HEIGHT}+0+0 +repage ${tmp_wall_image}; then
    logger -t $(basename $0) -s "Failed to create temp wallpaper image"
    exit 1
fi

cp ${tmp_lock_image} ${lock_image}
cp ${tmp_wall_image} ${wall_image}

rm -rf ${cache_dir}/tmp*.png

feh --bg-max ${wall_image}
